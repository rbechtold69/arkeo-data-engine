<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Marketplace | Provider Manager</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body>
<div class="card header-card">
    <div class="row-between header-top">
            <div class="header-left">
                <div class="header-brand-row">
                    <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                    <div class="header-brand">
                        <span class="brand-main">Arkeo Marketplace</span>
                        <span class="brand-sep">|</span>
                        <span class="brand-sub">Provider Manager</span>
                    </div>
                </div>
                <h1 id="headerMoniker"></h1>
                <div id="headerDescription" class="muted header-desc"></div>
            </div>
            <div class="header-right">
                <div class="header-line" id="headerPubkey">
                    <strong>Provider Pubkey:</strong>
                    <span class="inline"><span id="headerPubkeyValue"></span> <button class="copy-btn" onclick="copyPubkeyFromHeader()">Copy</button></span>
            </div>
            <div class="header-line" id="headerBalance"><strong>Hotwallet Balance:</strong></div>
            <div class="header-line muted" id="headerBlock"><strong>Current Block:</strong></div>
            <div class="header-line fixed-pill"><span id="headerRefreshPill" class="status-badge status-warn hidden">Loading...</span></div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Sentinel Info</h2>
    <div class="row">
        <div class="col">
            <div class="stack panel mb-8">
                <div class="pill-row">
                    <div class="status-badge status-warn" id="sentinelStatusBadgeTop">(loading)</div>
                </div>
                <div class="actions">
                    <button class="primary" onclick="controlSentinel('restart')">Restart Sentinel</button>
                    <button class="primary" onclick="controlSentinel('stop')">Stop Sentinel</button>
                    <button class="primary" onclick="controlSentinel('start')">Start Sentinel</button>
                    <button class="primary" onclick="runProviderClaims()">Provider Claims</button>
                    <button class="primary" onclick="runProviderTotals()">Provider Totals</button>
                </div>
            </div>
        </div>
        <div class="col">
            <div class="steps">
                <div class="step">
                    <h3>Step 1: Provide Sentinel Details</h3>
                    <p>Configure your sentinel settings before bonding a service.</p>
                    <p class="muted">* Edits may take 1–2 blocks to appear in the dashboard as the blockchain refreshes. Let the interface refresh to see the latest changes.</p>
                    <a class="btn" href="sentinel.html">Open Sentinel Form</a>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Provider Services</h2>
    <div class="row">
        <div class="col">
            <div class="panel mb-12">
                <div id="providerServices" class="muted">(loading services...)</div>
            </div>
        </div>
        <div class="col">
            <div class="steps">
                <div class="step">
                    <h3>Step 2: Add Provider Services</h3>
                    <p>Bond and configure provider services for the marketplace.</p>
                    <p class="muted">* Edits may take 1–2 blocks to appear in the dashboard as the blockchain refreshes. Let the interface refresh to see the latest changes.</p>
                    <a class="btn" href="provider.html">Open Provider Services Form</a>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Access Points</h2>
    <div id="endpointList" class="muted ws-normal"></div>
</div>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<div class="card">
    <div class="section">
        <h3>Debug</h3>
        <p id="version">Loading arkeod version...</p>
        <span id="refreshBadge" class="status-badge status-warn hidden mb-8">Refreshing…</span>
        <button class="primary" onclick="refreshInfo()">Refresh Info</button>
        <pre id="debugInfo">Loading...</pre>
        <h4>Sentinel Status</h4>
        <pre id="sentinelStatus">Loading...</pre>
    </div>
</div>

<div id="resultModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3 id="modalTitle">Result</h3>
        <pre id="modalBody"></pre>
        <button class="primary" onclick="closeModal()">OK</button>
    </div>
</div>

<script>
    let providerServicesData = [];
    let currentPubkey = "";

    async function refreshInfo() {
        const debugEl = document.getElementById("debugInfo");
        debugEl.textContent = "Loading...";
        const refreshBadge = document.getElementById("refreshBadge");
        const headerPill = document.getElementById("headerRefreshPill");
        if (refreshBadge) refreshBadge.style.display = "inline-block";
        if (headerPill) headerPill.style.display = "inline-block";
        try {
            const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
            const [provRes, balRes, keyRes, svcRes, allSvcRes, sentRes, heightRes, sCfgRes, metaRes] = await Promise.allSettled([
                fetchNoStore("http://localhost:9999/api/provider-info"),
                fetchNoStore("http://localhost:9999/api/balance"),
                fetchNoStore("http://localhost:9999/api/key"),
                fetchNoStore("http://localhost:9999/api/provider-services"),
                fetchNoStore("http://localhost:9999/api/services"),
                fetchNoStore("http://localhost:9999/api/sentinel-status"),
                fetchNoStore("http://localhost:9999/api/block-height"),
                fetchNoStore("http://localhost:9999/api/sentinel-config"),
                fetchNoStore("http://localhost:9999/api/sentinel-metadata?quiet=1"),
            ]);
            const parseSafe = async (settled) => {
                if (settled.status !== "fulfilled" || !settled.value) return { error: String(settled.reason || "request failed") };
                try {
                    if (!settled.value.ok) {
                        const text = await settled.value.text().catch(() => "");
                        return { error: `${settled.value.status} ${settled.value.statusText || ""}`, body: text };
                    }
                    return await settled.value.json();
                } catch (err) {
                    return { error: "invalid json", detail: String(err) };
                }
            };
            const prov = await parseSafe(provRes);
            const bal = await parseSafe(balRes);
            const key = await parseSafe(keyRes);
            const services = await parseSafe(svcRes);
            const allServices = await parseSafe(allSvcRes);
            const sentinelStatus = await parseSafe(sentRes);
            const height = await parseSafe(heightRes);
            const sentinelConfig = await parseSafe(sCfgRes);
            const meta = await parseSafe(metaRes);
            // Provider summary at top
            const metaCfg = (meta && meta.metadata && meta.metadata.config) || {};
            const envMeta = (prov && prov.provider_metadata) || {};
            const moniker =
                metaCfg.moniker ||
                metaCfg.provider_name ||
                envMeta.MONIKER ||
                envMeta.PROVIDER_NAME ||
                "";
            const desc = metaCfg.description || envMeta.DESCRIPTION || "";
            const bech32Pubkey =
                (prov && prov.pubkey && prov.pubkey.bech32) ||
                (key && key.pubkey && key.pubkey.bech32) ||
                "(unknown)";
            currentPubkey = bech32Pubkey || "";
            const shortPubkey = formatPubkeyShort(currentPubkey);
            const balanceAmt = formatBalance(bal);
            const blockHeight = formatBlockHeight(height);
            const summaryEl = document.getElementById("providerSummary");
            if (summaryEl) summaryEl.innerHTML = "";
            const headerMonikerEl = document.getElementById("headerMoniker");
            const headerDescEl = document.getElementById("headerDescription");
            const headerBalanceEl = document.getElementById("headerBalance");
            const headerBlockEl = document.getElementById("headerBlock");
            const headerPubEl = document.getElementById("headerPubkey");
            if (headerMonikerEl) headerMonikerEl.textContent = moniker || "";
            if (headerDescEl) headerDescEl.textContent = desc || "";
            if (headerBalanceEl) headerBalanceEl.innerHTML = `<strong>Hotwallet Balance:</strong> ${balanceAmt}`;
            if (headerBlockEl) headerBlockEl.innerHTML = `<strong>Current Block:</strong> ${blockHeight}`;
            if (headerPubEl) {
                const valEl = document.getElementById("headerPubkeyValue");
                if (valEl) valEl.textContent = shortPubkey;
                headerPubEl.dataset.fullPubkey = currentPubkey;
            }
            const svcEl = document.getElementById("providerServices");
            const svcLookup = {};
            if (allServices && Array.isArray(allServices.services)) {
                allServices.services.forEach(s => {
                    const rawId = s && (s.id ?? s.service_id ?? s.serviceID);
                    const key = rawId !== undefined && rawId !== null ? String(rawId) : "";
                    const name = s ? (s.name || s.service || s.label || "") : "";
                    if (key) {
                        svcLookup[key] = name;
                        // also store numeric key variant to be safe
                        const numKey = Number(key);
                        if (!Number.isNaN(numKey)) {
                            svcLookup[String(numKey)] = name;
                        }
                    }
                });
            }
            providerServicesData = services && Array.isArray(services.services) ? services.services : [];
            const sentinelServices = [];
            renderEndpointPanel(sentinelConfig, prov, envMeta);
            if (sentinelConfig && sentinelConfig.config && Array.isArray(sentinelConfig.config.services)) {
                sentinelConfig.config.services.forEach(ss => {
                    if (!ss || typeof ss !== "object") return;
                    const sid = ss.id !== undefined && ss.id !== null ? String(ss.id) : "";
                    const sname = ss.name || ss.service;
                    if (sid) sentinelServices.push({ id: sid, name: sname });
                    else if (sname) sentinelServices.push({ name: sname });
                });
            }
            if (providerServicesData && providerServicesData.length) {
                const items = providerServicesData.map((s, idx) => {
                    let rawId = "";
                    let rawName = "";
                    if (s && typeof s === "object") {
                        const candidateId = s.id ?? s.service_id ?? s.serviceID;
                        rawId = candidateId !== undefined && candidateId !== null ? String(candidateId) : "";
                        rawName = s.name || s.service || s.label || "";
                    } else if (typeof s === "string" || typeof s === "number") {
                        rawName = String(s);
                    }
                    if (!rawId && rawName && /^[0-9]+$/.test(rawName)) {
                        rawId = rawName;
                    }

                    let resolvedName = rawName;
                    const lookupById = rawId ? svcLookup[rawId] : "";
                    if (!resolvedName || resolvedName === rawId || /^[0-9]+$/.test(resolvedName)) {
                        resolvedName = lookupById || resolvedName || "(unknown service)";
                    }
                    if (!rawId && lookupById) {
                        rawId = Object.keys(svcLookup).find(k => svcLookup[k] === lookupById) || "";
                    }

                    const serviceIdLabel = rawId ? `Service ID: ${rawId}` : "Service ID: ?";
                    const statusVal = s && s.status;
                    const statusStr = statusVal === undefined ? "active" : String(statusVal).toLowerCase();
                    const isActive =
                        statusStr === "1" ||
                        statusStr === "active" ||
                        statusStr === "online" ||
                        statusStr === "true";
                    const statusLabel = isActive ? "Active" : "Inactive";
                    const statusClass = isActive ? "ok" : "err";
                    const inSentinel = sentinelServices.some(ss => {
                        if (!ss) return false;
                        const idMatch = rawId && (ss.id === rawId || String(ss.id) === String(rawId));
                        const nameMatch = resolvedName && ss.name && String(ss.name) === String(resolvedName);
                        return idMatch || nameMatch;
                    });
                    const sentinelBadge = inSentinel
                        ? '<span class="status-pill status-ok">Connected to Sentinel</span>'
                        : '<span class="status-pill status-err">Missing from Sentinel</span>';
                    return `
                        <div class="service-row full-width service-row-padded">
                            <div class="service-name full-width">
                                <span class="status-pill ${statusClass}">${statusLabel}</span>
                                <span class="service-pipe">|</span>
                                ${resolvedName} ${rawId ? `(${rawId})` : ""}
                                ${sentinelBadge}
                            </div>
                            <div class="service-actions-row">
                                <button class="primary" onclick="editService(${idx})">Edit</button>
                            </div>
                        </div>
                    `;
                });
                svcEl.innerHTML = `<div class="service-grid full-width">${items.join("")}</div>`;
            } else if (services && services.error) {
                svcEl.textContent = "Provider services unavailable";
            } else {
                svcEl.textContent = "No provider services found";
            }
            debugEl.textContent = JSON.stringify(
                {
                    provider_info: prov,
                    balance: bal,
                    key: key,
                    sentinel_metadata: meta,
                    provider_services: services,
                    all_services: allServices,
                    sentinel_status: sentinelStatus,
                    block_height: height,
                },
                null,
                2
            );
            updateSentinelStatusDisplay(sentinelStatus);
        } catch (e) {
            debugEl.textContent = "Failed to load info: " + e;
        }
        if (refreshBadge) refreshBadge.style.display = "none";
        if (headerPill) headerPill.style.display = "none";
    }

    function updateSentinelStatusDisplay(sentinelStatus) {
        const statusEl = document.getElementById("sentinelStatus");
        const badgeTop = document.getElementById("sentinelStatusBadgeTop");
        const rawStatus = (sentinelStatus && sentinelStatus.status) || "";
        const upper = rawStatus.toUpperCase();
        let cls = "status-warn";
        if (upper.includes("RUNNING")) cls = "status-ok";
        else if (upper.includes("FATAL") || upper.includes("STOP") || upper.includes("EXIT")) cls = "status-err";
        if (sentinelStatus && !sentinelStatus.error) {
            let cleaned = rawStatus.replace(/pid\s+\d+,\s*/gi, "").trim();
            cleaned = cleaned.replace(/^sentinel\s*/i, "").trim();
            const display = `Sentinel ${cleaned.replace(",", " :").trim() || "(unknown)"}`
                .replace(/\s+uptime\s+/i, " : Uptime ");
            if (badgeTop) {
                badgeTop.className = `status-badge ${cls}`;
                badgeTop.textContent = display;
            }
            statusEl.textContent = display;
        } else {
            statusEl.textContent = "Sentinel status unavailable";
        }
    }

    function formatBalance(balanceObj) {
        const coins =
            (balanceObj && balanceObj.balance && balanceObj.balance.result && Array.isArray(balanceObj.balance.result) && balanceObj.balance.result) ||
            (balanceObj && balanceObj.balance && balanceObj.balance.balances && Array.isArray(balanceObj.balance.balances) && balanceObj.balance.balances) ||
            [];
        if (!coins.length) return "(unknown)";
        const fmtCoin = (c) => {
            const amount = c.amount || c.Amount || "";
            const denom = c.denom || c.Denom || "";
            if (denom === "uarkeo") {
                const num = parseInt(amount || "0", 10);
                const val = num / 1e8;
                return `${val.toLocaleString("en-US", { minimumFractionDigits: 8, maximumFractionDigits: 8 })} ${denom}`;
            }
            return `${amount}${denom}`;
        };
        return coins.map(fmtCoin).join(", ");
    }

    function formatBlockHeight(heightObj) {
        const h =
            (heightObj && heightObj.height) ||
            (heightObj && heightObj.status && (heightObj.status.latest_block_height || (heightObj.status.SyncInfo && heightObj.status.SyncInfo.latest_block_height)));
        if (!h) return "(unknown)";
        const num = Number(h);
        if (!Number.isFinite(num)) return String(h);
        return num.toLocaleString("en-US");
    }

    function formatPubkeyShort(pk) {
        if (!pk) return "";
        const str = String(pk);
        if (str.length <= 17) return str;
        return `${str.slice(0, 9)}...${str.slice(-8)}`;
    }

    async function checkEndpoint(statusId, url, opts = {}) {
        const badge = document.getElementById(statusId);
        if (!badge) return;
        if (!url) {
            badge.className = "status-dot err";
            return;
        }
        const { appendStatusPath = false, pathOverride = "", allowOpaqueOk = false } = opts;
        let base = url.replace(/\/$/, "");
        if (base.startsWith("tcp://")) {
            base = "http://" + base.slice("tcp://".length);
        }
        let target = base;
        try {
            const parsed = new URL(base);
            if (pathOverride) {
                parsed.pathname = pathOverride;
                target = parsed.toString();
            } else if (appendStatusPath) {
                parsed.pathname = parsed.pathname && parsed.pathname !== "/" ? parsed.pathname : "/status";
                if (!parsed.pathname.endsWith("/status")) parsed.pathname = "/status";
                target = parsed.toString();
            }
        } catch (e) {
            if (pathOverride) {
                target = `${base}${pathOverride.startsWith("/") ? pathOverride : `/${pathOverride}`}`;
            } else if (appendStatusPath && !base.endsWith("/status")) {
                target = `${base}/status`;
            }
        }
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), 4000);
        try {
            const res = await fetch(target, { method: "GET", mode: "no-cors", signal: controller.signal });
            clearTimeout(timer);
            if (res.ok) {
                badge.className = "status-dot ok";
            } else if (res.type === "opaque") {
                badge.className = allowOpaqueOk ? "status-dot ok" : "status-dot warn";
            } else {
                badge.className = "status-dot err";
            }
        } catch (e) {
            clearTimeout(timer);
            badge.className = "status-dot err";
        }
    }

    async function refreshSentinelStatus() {
        try {
            const res = await fetch("http://localhost:9999/api/sentinel-status");
            const data = await res.json();
            updateSentinelStatusDisplay(data);
        } catch (e) {
            const badgeTop = document.getElementById("sentinelStatusBadgeTop");
            if (badgeTop) { badgeTop.className = "status-badge status-warn"; badgeTop.textContent = "unavailable"; }
        }
    }

    async function controlSentinel(action) {
        showResultModal("Sentinel Control", `Sending ${action}...`);
        try {
            const res = await fetch("http://localhost:9999/api/sentinel-control", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ action }),
            });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Sentinel Control", `${action} ok: ${JSON.stringify(data)}`);
                refreshInfo();
            } else {
                showResultModal("Sentinel Control", `${action} failed: ${JSON.stringify(data)}`);
            }
        } catch (e) {
                showResultModal("Sentinel Control", `${action} request error: ${e}`);
        }
    }

    async function runProviderClaims() {
        showResultModal("Provider Claims", "Running provider claims...");
        try {
            const res = await fetch("http://localhost:9999/api/provider-claims", { method: "POST" });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Provider Claims", JSON.stringify(data, null, 2));
            } else {
                showResultModal("Provider Claims", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Claims", "Request failed: " + e);
        }
    }

    async function runProviderTotals() {
        showResultModal("Provider Totals", "Running provider totals...");
        try {
            const res = await fetch("http://localhost:9999/api/provider-totals", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({}) });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Provider Totals", JSON.stringify(data, null, 2));
            } else {
                showResultModal("Provider Totals", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Totals", "Request failed: " + e);
        }
    }

    function showResultModal(title, bodyText) {
        const modal = document.getElementById("resultModal");
        const t = document.getElementById("modalTitle");
        const b = document.getElementById("modalBody");
        if (t) t.textContent = title || "Result";
        if (b) b.textContent = bodyText || "";
        if (modal) modal.style.display = "flex";
    }

    function closeModal() {
        const modal = document.getElementById("resultModal");
        if (modal) modal.style.display = "none";
    }

    async function renderEndpointPanel(sCfg, provObj, envMeta) {
        const el = document.getElementById("endpointList");
        if (!el) return;
        const envLower = (sCfg && sCfg.env) || {};
        const envFile = (sCfg && sCfg.env_file) || {};
        const pickEnv = (keyUpper) => {
            const lower = keyUpper.toLowerCase();
            return (envFile[keyUpper] ?? envLower[lower] ?? "");
        };
        const meta = (provObj && provObj.provider_metadata) || envMeta || {};
        const pickMeta = (key) => meta[key] || meta[key.toUpperCase()] || meta[key.toLowerCase()] || "";

        const arkeodNode = pickEnv("EXTERNAL_ARKEOD_NODE") || pickEnv("ARKEOD_NODE") || pickMeta("EXTERNAL_ARKEOD_NODE") || pickMeta("ARKEOD_NODE");
        const restApi = pickEnv("ARKEO_REST_API_PORT") || pickEnv("PROVIDER_HUB_URI") || pickMeta("ARKEO_REST_API_PORT") || pickMeta("PROVIDER_HUB_URI");
        const sentinelNode = pickEnv("SENTINEL_NODE") || pickMeta("SENTINEL_NODE");
        const sentinelPort = pickEnv("SENTINEL_PORT") || pickMeta("SENTINEL_PORT") || "3636";
        const sentinelFull = sentinelNode ? `${sentinelNode}:${sentinelPort}` : `(not set):${sentinelPort}`;
        const adminApiPort = pickEnv("ADMIN_API_PORT") || pickMeta("ADMIN_API_PORT") || "9999";
        const adminPort = pickEnv("ADMIN_PORT") || pickMeta("ADMIN_PORT") || "8080";

        const makeRow = (label, value, statusId) => {
            return `<div class="endpoint-row">
                <span id="${statusId}" class="status-dot warn"></span>
                <strong>${label}: </strong><span class="muted endpoint-url">${value || "(not set)"}</span>
            </div>`;
        };

        el.innerHTML = [
            `<div class="endpoint-section-title"><strong>External Access</strong></div>`,
            makeRow("Arkeo Node", arkeodNode, "arkeod-status"),
            makeRow("Arkeo RPC", restApi, "arkeorpc-status"),
            `<div class="endpoint-row"><strong>Sentinel RPC: </strong><span class="muted endpoint-url">${sentinelFull}</span></div>`,
            `<div class="endpoint-section-title"><strong>Internal Access</strong></div>`,
            makeRow("Sentinel RPC (Internal)", `http://localhost:${sentinelPort}`, "internal-sentinel-status"),
            makeRow("Admin API", `http://localhost:${adminApiPort}/api/version`, "internal-adminapi-status"),
            makeRow("Admin UI", `http://localhost:${adminPort}`, "internal-admin-status")
        ].join("");

        // Kick off reachability checks
        checkEndpoint("arkeod-status", arkeodNode, { pathOverride: "/health", allowOpaqueOk: true });
        checkEndpoint("arkeorpc-status", restApi, { pathOverride: "/cosmos/base/tendermint/v1beta1/node_info", allowOpaqueOk: true });
        checkEndpoint("internal-sentinel-status", `http://localhost:${sentinelPort}`, { pathOverride: "/metadata.json", allowOpaqueOk: true });
        checkEndpoint("internal-adminapi-status", `http://localhost:${adminApiPort}/api/version`, { allowOpaqueOk: true });
        checkEndpoint("internal-admin-status", `http://localhost:${adminPort}`, { allowOpaqueOk: true });
    }

    async function getVersion() {
        try {
            let res = await fetch("http://localhost:9999/api/version");
            let data = await res.json();
            if (data.arkeod_version) {
                document.getElementById("version").textContent = "arkeod version: " + data.arkeod_version;
            } else if (data.error) {
                document.getElementById("version").textContent = "Error getting version: " + data.error;
            } else {
                document.getElementById("version").textContent = "Unknown version response";
            }
        } catch (e) {
            document.getElementById("version").textContent = "Error fetching version: " + e;
        }
    }

    function editService(idx) {
        if (!providerServicesData || !providerServicesData[idx]) return;
        try {
            localStorage.setItem("providerServiceEdit", JSON.stringify(providerServicesData[idx]));
        } catch (e) {
            console.warn("Failed to cache service for edit", e);
        }
        window.location.href = "provider.html";
    }

    function copyPubkeyFromHeader() {
        const el = document.getElementById("headerPubkey");
        const full = (el && el.dataset.fullPubkey) || currentPubkey || "";
        if (full) {
            copyPubkey(full);
        } else {
            alert("Pubkey unavailable");
        }
    }

    async function copyPubkey(val) {
        try {
            await navigator.clipboard.writeText(val);
            alert("Pubkey copied");
        } catch (e) {
            alert("Failed to copy pubkey");
        }
    }

    window.addEventListener('load', () => {
        getVersion();
        refreshInfo();
        refreshSentinelStatus();
        setInterval(refreshSentinelStatus, 5000);
        setInterval(refreshInfo, 10000);
    });
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            refreshInfo();
        }
    });
    window.addEventListener('pageshow', (event) => {
        if (event.persisted) {
            refreshInfo();
        }
    });
</script>

</body>
</html>
